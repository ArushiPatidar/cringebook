<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Call - CringeBook</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="notification-service.js"></script>
    <style>
        /* Material Design 3 Color Scheme and Components */
        :root {
          --md-primary: #3f51b5;
          --md-primary-dark: #303f9f;
          --md-error: #b00020;
          --md-surface: #ffffff;
          --md-background: #fafafa;
          --md-on-primary: #ffffff;
          --md-on-surface: #000000;
          --md-elevation-1: 0px 1px 3px rgba(0, 0, 0, 0.12), 0px 1px 2px rgba(0, 0, 0, 0.24);
          --md-border-radius-large: 16px;
        }

        * {
          box-sizing: border-box;
        }

        body {
          font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
          background-color: #000;
          color: white;
          margin: 0;
          padding: 0;
          overflow: hidden;
        }

        .video-container {
          position: relative;
          width: 100vw;
          height: 100vh;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .remote-video {
          width: 100%;
          height: 100%;
          object-fit: cover;
          background: #222;
        }

        .local-video {
          position: absolute;
          top: 20px;
          right: 20px;
          width: 200px;
          height: 150px;
          object-fit: cover;
          border-radius: var(--md-border-radius-large);
          border: 2px solid white;
          background: #333;
        }

        .controls {
          position: absolute;
          bottom: 30px;
          left: 50%;
          transform: translateX(-50%);
          display: flex;
          gap: 20px;
          z-index: 1000;
        }

        .control-btn {
          width: 60px;
          height: 60px;
          border-radius: 50%;
          border: none;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          transition: all 0.2s ease;
          font-size: 24px;
        }

        .control-btn:hover {
          transform: scale(1.1);
        }

        .btn-mute {
          background: rgba(255, 255, 255, 0.2);
          color: white;
        }

        .btn-mute.muted {
          background: var(--md-error);
        }

        .btn-video {
          background: rgba(255, 255, 255, 0.2);
          color: white;
        }

        .btn-video.disabled {
          background: var(--md-error);
        }

        .btn-hangup {
          background: var(--md-error);
          color: white;
        }

        .call-info {
          position: absolute;
          top: 20px;
          left: 20px;
          background: rgba(0, 0, 0, 0.5);
          padding: 16px;
          border-radius: var(--md-border-radius-large);
          color: white;
        }

        .call-status {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          text-align: center;
          background: rgba(0, 0, 0, 0.7);
          padding: 32px;
          border-radius: var(--md-border-radius-large);
          color: white;
        }

        .call-status h2 {
          margin: 0 0 16px 0;
          font-size: 24px;
        }

        .call-status p {
          margin: 0;
          opacity: 0.8;
        }

        .incoming-call {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.9);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 2000;
        }

        .incoming-call-card {
          background: var(--md-surface);
          color: var(--md-on-surface);
          padding: 32px;
          border-radius: var(--md-border-radius-large);
          text-align: center;
          box-shadow: var(--md-elevation-1);
          min-width: 300px;
        }

        .incoming-call-avatar {
          width: 80px;
          height: 80px;
          border-radius: 50%;
          background: var(--md-primary);
          color: var(--md-on-primary);
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 32px;
          margin: 0 auto 16px;
        }

        .incoming-call-actions {
          display: flex;
          gap: 16px;
          margin-top: 24px;
          justify-content: center;
        }

        .btn-accept {
          background: #4caf50;
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 30px;
          cursor: pointer;
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .btn-decline {
          background: var(--md-error);
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 30px;
          cursor: pointer;
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .hidden {
          display: none !important;
        }

        @media (max-width: 768px) {
          .local-video {
            width: 120px;
            height: 90px;
            top: 10px;
            right: 10px;
          }
          
          .controls {
            bottom: 20px;
            gap: 15px; /* Reduce gap on mobile */
          }
          
          .control-btn {
            width: 50px;
            height: 50px;
            font-size: 20px;
          }
          
          .call-info {
            top: 10px;
            left: 10px;
            padding: 12px;
            font-size: 14px;
          }
          
          .incoming-call-card {
            margin: 20px;
            max-width: calc(100vw - 40px);
          }
          
          /* Ensure controls are always visible on mobile when call is active */
          .controls.mobile-visible {
            display: flex !important;
          }
        }
        
        /* Add touch-friendly hover effects for mobile */
        @media (max-width: 768px) and (hover: none) {
          .control-btn:active {
            transform: scale(0.95);
            background-color: rgba(255, 255, 255, 0.3);
          }
        }
    </style>
</head>
<body>

<div class="video-container">
    <video id="remoteVideo" class="remote-video" autoplay playsinline></video>
    <video id="localVideo" class="local-video" autoplay muted playsinline></video>
    
    <div class="call-info" id="callInfo">
        <div><strong id="callerName">Connecting...</strong></div>
        <div id="callDuration">00:00</div>
    </div>
    
    <div class="call-status" id="callStatus">
        <h2>Setting up call...</h2>
        <p>Please wait while we connect you</p>
    </div>
    
    <div class="controls" id="controls" style="display: none;">
        <button class="control-btn btn-mute" id="muteBtn" onclick="toggleMute()">
            <span class="material-icons">mic</span>
        </button>
        <button class="control-btn btn-video" id="videoBtn" onclick="toggleVideo()">
            <span class="material-icons">videocam</span>
        </button>
        <button class="control-btn btn-hangup" onclick="hangUp()">
            <span class="material-icons">call_end</span>
        </button>
    </div>
</div>

<div class="incoming-call hidden" id="incomingCall">
    <div class="incoming-call-card">
        <div class="incoming-call-avatar" id="incomingAvatar">F</div>
        <h3 id="incomingCallerName">Friend Name</h3>
        <p>Incoming video call</p>
        <div class="incoming-call-actions">
            <button class="btn-accept" onclick="acceptCall()">
                <span class="material-icons">call</span>
                Accept
            </button>
            <button class="btn-decline" onclick="declineCall()">
                <span class="material-icons">call_end</span>
                Decline
            </button>
        </div>
    </div>
</div>

<script>
    let localStream = null;
    let remoteStream = null;
    let peerConnection = null;
    let isInitiator = false;
    let isMuted = false;
    let isVideoEnabled = true;
    let callStartTime = null;
    let callDurationInterval = null;
    let friendId = null;
    let friendName = null;
    let websocket = null;
    let currentUserId = null;
    let currentUserName = null;

    // Get friend info from URL params
    const urlParams = new URLSearchParams(window.location.search);
    friendId = urlParams.get('friendId');
    friendName = urlParams.get('friendName') || 'Friend';
    isInitiator = urlParams.get('initiator') === 'true';

    // WebRTC configuration
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    };

    function getTokenFromCookie() {
        const match = document.cookie.match(/(^| )Authorization=([^;]+)/);
        return match ? decodeURIComponent(match[2]) : null;
    }

    async function getCurrentUserInfo() {
        const token = getTokenFromCookie();
        if (!token) return null;
        
        try {
            const response = await fetch('/api/users/profile', {
                headers: { 'Authorization': token }
            });
            
            if (response.ok) {
                const userDetails = await response.json();
                currentUserName = userDetails.fullName || userDetails.username || 'User';
                return userDetails;
            }
        } catch (error) {
            console.error('Error getting current user info:', error);
        }
        return null;
    }

    function getCurrentUserId() {
        const token = getTokenFromCookie();
        if (!token) return null;
        
        try {
            const payload = JSON.parse(atob(token.split('.')[1]));
            return payload.userId || payload.sub;
        } catch (e) {
            return null;
        }
    }

    async function initializeCall() {
        try {
            currentUserId = getCurrentUserId();
            await getCurrentUserInfo(); // Get current user's name
            if (!currentUserId) {
                showError('Authentication required');
                return;
            }

            // Connect to WebSocket
            connectWebSocket();

            // Get user media
            localStream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: true
            });
            
            document.getElementById('localVideo').srcObject = localStream;
            
            // Create peer connection
            peerConnection = new RTCPeerConnection(configuration);
            
            // Add local stream to peer connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
            
            // Handle remote stream
            peerConnection.ontrack = (event) => {
                remoteStream = event.streams[0];
                document.getElementById('remoteVideo').srcObject = remoteStream;
                document.getElementById('callStatus').style.display = 'none';
                const controlsElement = document.getElementById('controls');
                controlsElement.style.display = 'flex';
                // Add mobile-visible class on mobile devices
                if (window.innerWidth <= 768) {
                    controlsElement.classList.add('mobile-visible');
                }
                startCallTimer();
            };
            
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate && websocket && websocket.readyState === WebSocket.OPEN) {
                    sendSignalingMessage({
                        type: 'ice-candidate',
                        candidate: event.candidate,
                        toUserId: friendId
                    });
                }
            };
            
            // Update UI
            document.getElementById('callerName').textContent = friendName;
            
            // If initiator, create offer after a short delay
            if (isInitiator) {
                setTimeout(() => createOffer(), 1000);
            }
            
        } catch (error) {
            console.error('Error initializing call:', error);
            showError('Failed to access camera/microphone');
        }
    }

    function connectWebSocket() {
        const token = getTokenFromCookie();
        if (!token) {
            showError('Authentication required');
            return;
        }

        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        websocket = new WebSocket(`${wsProtocol}//${window.location.host}/video-call-ws?token=${encodeURIComponent(token)}`);
        
        websocket.onopen = () => {
            console.log('WebSocket connected');
            
            // If this is the initiator, send call request
            if (isInitiator) {
                sendSignalingMessage({
                    type: 'call-request',
                    toUserId: friendId,
                    fromUserName: currentUserName || 'User'
                });
            }
        };
        
        websocket.onmessage = async (event) => {
            const message = JSON.parse(event.data);
            await handleSignalingMessage(message);
        };
        
        websocket.onclose = () => {
            console.log('WebSocket disconnected');
        };
        
        websocket.onerror = (error) => {
            console.error('WebSocket error:', error);
            showError('Connection error');
        };
    }

    async function handleSignalingMessage(message) {
        try {
            switch (message.type) {
                case 'incoming-call':
                    showIncomingCall(message.fromUserId, message.fromUserName);
                    break;
                    
                case 'call-response':
                    if (message.accepted) {
                        console.log('Call accepted');
                    } else {
                        showError('Call declined');
                        setTimeout(() => window.close(), 2000);
                    }
                    break;
                    
                case 'offer':
                    await handleOffer(message.offer);
                    break;
                    
                case 'answer':
                    await handleAnswer(message.answer);
                    break;
                    
                case 'ice-candidate':
                    await handleIceCandidate(message.candidate);
                    break;
                    
                case 'call-ended':
                    showError('Call ended by remote user');
                    setTimeout(() => window.close(), 2000);
                    break;
            }
        } catch (error) {
            console.error('Error handling signaling message:', error);
        }
    }

    async function createOffer() {
        try {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            sendSignalingMessage({
                type: 'offer',
                offer: offer,
                toUserId: friendId
            });
        } catch (error) {
            console.error('Error creating offer:', error);
        }
    }

    async function handleOffer(offer) {
        try {
            await peerConnection.setRemoteDescription(offer);
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            sendSignalingMessage({
                type: 'answer',
                answer: answer,
                toUserId: friendId
            });
        } catch (error) {
            console.error('Error handling offer:', error);
        }
    }

    async function handleAnswer(answer) {
        try {
            await peerConnection.setRemoteDescription(answer);
        } catch (error) {
            console.error('Error handling answer:', error);
        }
    }

    async function handleIceCandidate(candidate) {
        try {
            await peerConnection.addIceCandidate(candidate);
        } catch (error) {
            console.error('Error handling ICE candidate:', error);
        }
    }

    function sendSignalingMessage(message) {
        if (websocket && websocket.readyState === WebSocket.OPEN) {
            websocket.send(JSON.stringify(message));
        }
    }

    function showIncomingCall(fromUserId, fromUserName) {
        // Show incoming call UI (this would be for the receiving side)
        // For simplicity, auto-accept for now
        setTimeout(() => {
            acceptCall(fromUserId);
        }, 1000);
    }

    function acceptCall(fromUserId) {
        sendSignalingMessage({
            type: 'call-response',
            toUserId: fromUserId,
            accepted: true
        });
    }

    function startCallTimer() {
        callStartTime = new Date();
        callDurationInterval = setInterval(updateCallDuration, 1000);
    }

    function updateCallDuration() {
        if (callStartTime) {
            const now = new Date();
            const duration = Math.floor((now - callStartTime) / 1000);
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;
            document.getElementById('callDuration').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
    }

    function toggleMute() {
        if (localStream) {
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = isMuted;
                isMuted = !isMuted;
                
                const muteBtn = document.querySelector('.btn-mute');
                const icon = muteBtn.querySelector('.material-icons');
                
                if (isMuted) {
                    muteBtn.classList.add('disabled');
                    icon.textContent = 'mic_off';
                } else {
                    muteBtn.classList.remove('disabled');
                    icon.textContent = 'mic';
                }
            }
        }
    }

    function toggleVideo() {
        if (localStream) {
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !isVideoEnabled;
                isVideoEnabled = !isVideoEnabled;
                
                const videoBtn = document.querySelector('.btn-video');
                const icon = videoBtn.querySelector('.material-icons');
                
                if (!isVideoEnabled) {
                    videoBtn.classList.add('disabled');
                    icon.textContent = 'videocam_off';
                } else {
                    videoBtn.classList.remove('disabled');
                    icon.textContent = 'videocam';
                }
            }
        }
    }

    function hangUp() {
        // Send end call message
        if (websocket && websocket.readyState === WebSocket.OPEN) {
            sendSignalingMessage({
                type: 'end-call',
                toUserId: friendId
            });
        }
        
        // Clean up
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }
        
        if (peerConnection) {
            peerConnection.close();
        }
        
        if (websocket) {
            websocket.close();
        }
        
        if (callDurationInterval) {
            clearInterval(callDurationInterval);
        }
        
        window.close();
    }

    function showError(message) {
        const statusDiv = document.getElementById('callStatus');
        statusDiv.innerHTML = `
            <h2>Error</h2>
            <p>${message}</p>
        `;
        statusDiv.style.display = 'block';
        document.getElementById('controls').style.display = 'none';
    }

    // Initialize call when page loads
    window.onload = initializeCall;
    
    // Clean up when page unloads
    window.addEventListener('beforeunload', () => {
        hangUp();
    });
</script>
</body>
</html>